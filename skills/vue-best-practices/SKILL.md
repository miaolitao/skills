---
name: vue-best-practices
description: 必须用于 Vue.js 任务。强烈推荐使用 Composition API 配合 `<script setup>` 和 TypeScript 作为标准方法。涵盖 Vue 3、SSR、Volar、vue-tsc。用于任何 Vue、.vue 文件、Vue Router、Pinia 或 Vite with Vue 工作。除非项目明确要求 Options API,否则始终使用 Composition API。
license: MIT
metadata:
  author: github.com/vuejs-ai
  version: "17.0.0"
---

Vue 3 最佳实践、常见陷阱和性能优化。

### 响应式(Reactivity)
- 在脚本中访问 ref() 值时未使用 .value → 参见 [ref-value-access](reference/ref-value-access.md)
- 解构 reactive() 对象,丢失响应性 → 参见 [reactive-destructuring](reference/reactive-destructuring.md)
- 在 ref() 和 reactive() 之间选择状态 → 参见 [prefer-ref-over-reactive](reference/prefer-ref-over-reactive.md)
- 访问数组和集合中的 refs → 参见 [refs-in-collections-need-value](reference/refs-in-collections-need-value.md)
- 大对象或外部库数据的开销 → 参见 [shallow-ref-for-performance](reference/shallow-ref-for-performance.md)
- 在模板表达式中使用嵌套 refs → 参见 [template-ref-unwrapping-top-level](reference/template-ref-unwrapping-top-level.md)
- 使用 === 运算符比较响应式对象 → 参见 [reactivity-proxy-identity-hazard](reference/reactivity-proxy-identity-hazard.md)
- 库实例在响应式状态中损坏 → 参见 [reactivity-markraw-for-non-reactive](reference/reactivity-markraw-for-non-reactive.md)
- 期望 watchers 对每次状态变化都触发 → 参见 [reactivity-same-tick-batching](reference/reactivity-same-tick-batching.md)
- 集成外部状态管理库 → 参见 [reactivity-external-state-integration](reference/reactivity-external-state-integration.md)
- 追踪意外的重新渲染和状态更新 → 参见 [reactivity-debugging-hooks](reference/reactivity-debugging-hooks.md)
- 使用 watchEffect 而不是 computed 派生状态 → 参见 [reactivity-computed-over-watcheffect-mutations](reference/reactivity-computed-over-watcheffect-mutations.md)

### 计算属性(Computed)
- Computed getter 进行 API 调用或修改 → 参见 [computed-no-side-effects](reference/computed-no-side-effects.md)
- 修改 computed 值导致更改意外丢失 → 参见 [computed-return-value-readonly](reference/computed-return-value-readonly.md)
- Computed 属性在预期时未更新 → 参见 [computed-conditional-dependencies](reference/computed-conditional-dependencies.md)
- 排序或反转数组破坏原始数据 → 参见 [computed-array-mutation](reference/computed-array-mutation.md)
- 昂贵的操作在每次渲染时运行过于频繁 → 参见 [computed-vs-methods-caching](reference/computed-vs-methods-caching.md)
- 尝试向 computed 属性传递参数 → 参见 [computed-no-parameters](reference/computed-no-parameters.md)
- 复杂条件使内联 class 绑定膨胀 → 参见 [computed-properties-for-class-logic](reference/computed-properties-for-class-logic.md)

### 侦听器(Watchers)
- 需要侦听响应式对象属性 → 参见 [watch-reactive-property-getter](reference/watch-reactive-property-getter.md)
- 大型嵌套数据结构导致性能问题 → 参见 [watch-deep-performance](reference/watch-deep-performance.md)
- 异步操作用陈旧数据覆盖 → 参见 [watch-async-cleanup](reference/watch-async-cleanup.md)
- 在异步回调内部创建 watchers → 参见 [watch-async-creation-memory-leak](reference/watch-async-creation-memory-leak.md)
- await 之后访问的依赖项未跟踪 → 参见 [watcheffect-async-dependency-tracking](reference/watcheffect-async-dependency-tracking.md)
- 需要在 watchers 中访问更新后的 DOM → 参见 [watch-flush-timing](reference/watch-flush-timing.md)
- 不确定使用 watch 还是 watchEffect → 参见 [watch-vs-watcheffect](reference/watch-vs-watcheffect.md)
- 重复初始调用和 watch 回调 → 参见 [watch-immediate-option](reference/watch-immediate-option.md)
- 无法正确比较新旧值 → 参见 [watch-deep-same-object-reference](reference/watch-deep-same-object-reference.md)
- 模板 refs 显示为 null 或陈旧 → 参见 [watcheffect-flush-post-for-refs](reference/watcheffect-flush-post-for-refs.md)

### 组件(Components)
- Prop 值从子组件被更改 → 参见 [props-are-read-only](reference/props-are-read-only.md)
- 父组件无法访问 script setup 中的子组件 ref 数据 → 参见 [component-ref-requires-defineexpose](reference/component-ref-requires-defineexpose.md)
- 子组件抛出"组件未找到"错误 → 参见 [local-components-not-in-descendants](reference/local-components-not-in-descendants.md)
- 自定义组件上的 click 监听器不触发 → 参见 [click-events-on-components](reference/click-events-on-components.md)
- HTML 模板解析破坏 Vue 组件语法 → 参见 [in-dom-template-parsing-caveats](reference/in-dom-template-parsing-caveats.md)
- 祖父组件无法监听孙子组件触发的事件 → 参见 [component-events-dont-bubble](reference/component-events-dont-bubble.md)
- 由于命名冲突渲染错误的组件 → 参见 [component-naming-conflicts](reference/component-naming-conflicts.md)
- 区分 Vue 组件和原生元素 → 参见 [component-naming-pascalcase](reference/component-naming-pascalcase.md)
- 父组件样式不应用于多根组件 → 参见 [multi-root-component-class-attrs](reference/multi-root-component-class-attrs.md)
- 递归组件需要引用自身 → 参见 [self-referencing-component-name](reference/self-referencing-component-name.md)
- 打包包含未使用的组件 → 参见 [prefer-local-component-registration](reference/prefer-local-component-registration.md)
- 通过组件 ref 访问导致紧耦合 → 参见 [prefer-props-emit-over-component-refs](reference/prefer-props-emit-over-component-refs.md)

### Props 和 Emits
- Boolean prop 未按预期解析 → 参见 [prop-boolean-casting-order](reference/prop-boolean-casting-order.md)
- Composable 在 props 更改时未更新 → 参见 [prop-composable-reactivity-loss](reference/prop-composable-reactivity-loss.md)
- defineProps 中引用的变量导致错误 → 参见 [prop-defineprops-scope-limitation](reference/prop-defineprops-scope-limitation.md)
- 解构的 props 未更新 watchers → 参见 [prop-destructured-watch-getter](reference/prop-destructured-watch-getter.md)
- Prop 验证需要组件实例数据 → 参见 [prop-validation-before-instance](reference/prop-validation-before-instance.md)
- 组件触发未声明的事件导致警告 → 参见 [declare-emits-for-documentation](reference/declare-emits-for-documentation.md)
- defineEmits 在函数或条件语句内部使用 → 参见 [defineEmits-must-be-top-level](reference/defineEmits-must-be-top-level.md)
- defineEmits 同时具有类型和运行时参数 → 参见 [defineEmits-no-runtime-and-type-mixed](reference/defineEmits-no-runtime-and-type-mixed.md)
- 模板和脚本中的事件名称不一致 → 参见 [emit-kebab-case-in-templates](reference/emit-kebab-case-in-templates.md)
- 事件载荷在开发期间需要验证 → 参见 [emit-validation-for-complex-payloads](reference/emit-validation-for-complex-payloads.md)
- 原生事件监听器不响应点击 → 参见 [native-event-collision-with-emits](reference/native-event-collision-with-emits.md)
- 点击时组件事件触发两次 → 参见 [undeclared-emits-double-firing](reference/undeclared-emits-double-firing.md)

### 模板(Templates)
- 将不受信任的用户内容渲染为 HTML → 参见 [v-html-xss-security](reference/v-html-xss-security.md)
- 过滤或有条件地隐藏列表项 → 参见 [no-v-if-with-v-for](reference/no-v-if-with-v-for.md)
- 列表项意外消失或交换状态 → 参见 [v-for-key-attribute](reference/v-for-key-attribute.md)
- 使用语句时出现模板编译错误 → 参见 [template-expressions-restrictions](reference/template-expressions-restrictions.md)
- 动态指令参数无法正常工作 → 参见 [dynamic-argument-constraints](reference/dynamic-argument-constraints.md)
- 模板中的函数意外修改数据 → 参见 [template-functions-no-side-effects](reference/template-functions-no-side-effects.md)
- v-else 元素始终无条件渲染 → 参见 [v-else-must-follow-v-if](reference/v-else-must-follow-v-if.md)
- 循环中的子组件显示未定义的数据 → 参见 [v-for-component-props](reference/v-for-component-props.md)
- 排序或反转后数组顺序发生变化 → 参见 [v-for-computed-reverse-sort](reference/v-for-computed-reverse-sort.md)
- 范围迭代时出现差一错误 → 参见 [v-for-range-starts-at-one](reference/v-for-range-starts-at-one.md)
- 过滤或排序列表的性能问题 → 参见 [v-for-use-computed-for-filtering](reference/v-for-use-computed-for-filtering.md)
- "无法读取 undefined 的属性"运行时错误 → 参见 [v-if-null-check-order](reference/v-if-null-check-order.md)
- 在条件渲染时选择 v-if 还是 v-show → 参见 [v-if-vs-v-show-performance](reference/v-if-vs-v-show-performance.md)
- v-show 或 v-else 在 template 元素上不工作 → 参见 [v-show-template-limitation](reference/v-show-template-limitation.md)

### 模板引用(Template Refs)
- 元素有条件隐藏时 Ref 变为 null → 参见 [template-ref-null-with-v-if](reference/template-ref-null-with-v-if.md)
- Ref 数组索引与数据数组不匹配 → 参见 [template-ref-v-for-order](reference/template-ref-v-for-order.md)
- 重构模板 ref 名称在代码中静默失败 → 参见 [use-template-ref-vue35](reference/use-template-ref-vue35.md)

### 表单和 v-model
- 使用 v-model 时初始表单值未显示 → 参见 [v-model-ignores-html-attributes](reference/v-model-ignores-html-attributes.md)
- Textarea 内容更改未更新 ref → 参见 [textarea-no-interpolation](reference/textarea-no-interpolation.md)
- iOS 用户无法选择下拉菜单的第一个选项 → 参见 [select-initial-value-ios-bug](reference/select-initial-value-ios-bug.md)
- 父组件和子组件的值不同 → 参见 [define-model-default-value-sync](reference/define-model-default-value-sync.md)
- 需要在子组件中处理 v-model 修饰符 → 参见 [definemodel-hidden-modifier-props](reference/definemodel-hidden-modifier-props.md)
- 对象属性更改未同步到父组件 → 参见 [definemodel-object-mutation-no-emit](reference/definemodel-object-mutation-no-emit.md)
- 需要在更改后立即使用更新后的值 → 参见 [definemodel-value-next-tick](reference/definemodel-value-next-tick.md)
- 中文/日文输入的实时搜索/验证损坏 → 参见 [v-model-ime-composition](reference/v-model-ime-composition.md)
- 数字输入返回空字符串而不是零 → 参见 [v-model-number-modifier-behavior](reference/v-model-number-modifier-behavior.md)
- 将 Vue 2 组件迁移到 Vue 3 → 参见 [v-model-vue3-breaking-changes](reference/v-model-vue3-breaking-changes.md)
- 自定义复选框值未在表单中提交 → 参见 [checkbox-true-false-value-form-submission](reference/checkbox-true-false-value-form-submission.md)

### 事件和修饰符(Events & Modifiers)
- 链式多个事件修饰符产生意外结果 → 参见 [event-modifier-order-matters](reference/event-modifier-order-matters.md)
- 需要仅处理事件一次 → 参见 [event-once-modifier-for-single-use](reference/event-once-modifier-for-single-use.md)
- 键盘快捷键使用意外的修饰键组合触发 → 参见 [exact-modifier-for-precise-shortcuts](reference/exact-modifier-for-precise-shortcuts.md)
- 键盘快捷键不使用系统修饰键触发 → 参见 [keyup-modifier-timing](reference/keyup-modifier-timing.md)
- 使用左手鼠标或非标准输入设备 → 参见 [mouse-button-modifiers-intent](reference/mouse-button-modifiers-intent.md)
- 同时阻止默认浏览器操作和滚动性能 → 参见 [no-passive-with-prevent](reference/no-passive-with-prevent.md)

### 生命周期(Lifecycle)
- 生命周期钩子不异步执行 → 参见 [lifecycle-hooks-synchronous-registration](reference/lifecycle-hooks-synchronous-registration.md)
- 组件挂载前 DOM 访问失败 → 参见 [lifecycle-dom-access-timing](reference/lifecycle-dom-access-timing.md)
- 未移除的事件监听器导致内存泄漏 → 参见 [cleanup-side-effects](reference/cleanup-side-effects.md)
- SSR 渲染与客户端水合不同 → 参见 [lifecycle-ssr-awareness](reference/lifecycle-ssr-awareness.md)
- 昂贵的操作严重降低性能 → 参见 [updated-hook-performance](reference/updated-hook-performance.md)
- 状态更改后 DOM 读取返回陈旧值 → 参见 [dom-update-timing-nexttick](reference/dom-update-timing-nexttick.md)

### 插槽(Slots)
- 在插槽内容中访问子组件数据 → 参见 [slot-render-scope-parent-only](reference/slot-render-scope-parent-only.md)
- 混合使用命名插槽和作用域插槽 → 参见 [slot-named-scoped-explicit-default](reference/slot-named-scoped-explicit-default.md)
- 在原生 HTML 元素上使用 v-slot → 参见 [slot-v-slot-on-components-or-templates-only](reference/slot-v-slot-on-components-or-templates-only.md)
- 不必要地渲染空包装元素 → 参见 [slot-conditional-rendering-with-slots](reference/slot-conditional-rendering-with-slots.md)
- 作用域插槽 props 缺乏 TypeScript 类型安全 → 参见 [slot-define-slots-for-typescript](reference/slot-define-slots-for-typescript.md)
- 渲染空组件插槽时没有默认值 → 参见 [slot-fallback-content-default-values](reference/slot-fallback-content-default-values.md)
- 包装组件破坏子组件插槽功能 → 参见 [slot-forwarding-to-child-components](reference/slot-forwarding-to-child-components.md)
- 对插槽内容去向感到困惑 → 参见 [slot-implicit-default-content](reference/slot-implicit-default-content.md)
- 期望在作用域插槽 props 中有 name 属性 → 参见 [slot-name-reserved-prop](reference/slot-name-reserved-prop.md)
- 在无渲染组件和组合式函数之间选择 → 参见 [slot-renderless-components-vs-composables](reference/slot-renderless-components-vs-composables.md)

### Provide/Inject
- 提供者更改时注入的值未更新 → 参见 [provide-inject-reactivity-not-automatic](reference/provide-inject-reactivity-not-automatic.md)
- 异步操作后调用 provide 静默失败 → 参见 [provide-inject-synchronous-setup](reference/provide-inject-synchronous-setup.md)
- 大型应用中字符串键冲突 → 参见 [provide-inject-symbol-keys](reference/provide-inject-symbol-keys.md)
- 追踪提供的值来自何处 → 参见 [provide-inject-debugging-challenges](reference/provide-inject-debugging-challenges.md)
- 多个组件共享相同的默认对象 → 参见 [provide-inject-default-value-factory](reference/provide-inject-default-value-factory.md)
- 状态修改分散在各个组件中 → 参见 [provide-inject-mutations-in-provider](reference/provide-inject-mutations-in-provider.md)
- 通过多个组件层传递 props → 参见 [avoid-prop-drilling-use-provide-inject](reference/avoid-prop-drilling-use-provide-inject.md)

### Attrs
- 内部和穿透事件处理程序都执行 → 参见 [attrs-event-listener-merging](reference/attrs-event-listener-merging.md)
- 在 JavaScript 代码中访问连字符属性 → 参见 [attrs-hyphenated-property-access](reference/attrs-hyphenated-property-access.md)
- 使用 watch() 侦听穿透属性的更改 → 参见 [attrs-not-reactive](reference/attrs-not-reactive.md)
- 显式属性被穿透值覆盖 → 参见 [fallthrough-attrs-overwrite-vue3](reference/fallthrough-attrs-overwrite-vue3.md)
- 属性应用于包装器中的错误元素 → 参见 [inheritattrs-false-for-wrapper-components](reference/inheritattrs-false-for-wrapper-components.md)

### 组合式函数(Composables)
- 组合式函数具有影响外部状态的意外副作用 → 参见 [composable-avoid-hidden-side-effects](reference/composable-avoid-hidden-side-effects.md)
- 组合式函数在 setup 上下文外部或异步调用 → 参见 [composable-call-location-restrictions](reference/composable-call-location-restrictions.md)
- 从较小的专注组合式函数构建复杂逻辑 → 参见 [composable-composition-pattern](reference/composable-composition-pattern.md)
- 不一致的组合式函数名称或解构丢失响应性 → 参见 [composable-naming-return-pattern](reference/composable-naming-return-pattern.md)
- 组合式函数具有许多可选参数或令人困惑的参数顺序 → 参见 [composable-options-object-pattern](reference/composable-options-object-pattern.md)
- 需要防止组合式函数状态的不受控修改 → 参见 [composable-readonly-state](reference/composable-readonly-state.md)
- 输入更改时组合式函数响应式依赖项未更新 → 参见 [composable-tovalue-inside-watcheffect](reference/composable-tovalue-inside-watcheffect.md)
- 不确定逻辑是否属于组合式函数或实用函数 → 参见 [composable-vs-utility-functions](reference/composable-vs-utility-functions.md)

### Composition API
- 优化生产打包大小和性能 → 参见 [composition-api-bundle-size-minification](reference/composition-api-bundle-size-minification.md)
- Composition API 代码变得分散且难以维护 → 参见 [composition-api-code-organization](reference/composition-api-code-organization.md)
- 修复 mixins 中的命名冲突和不清楚的数据来源 → 参见 [composition-api-mixins-replacement](reference/composition-api-mixins-replacement.md)
- 将函数式模式错误地应用于 Vue 状态 → 参见 [composition-api-not-functional-programming](reference/composition-api-not-functional-programming.md)
- 逐步迁移大型 Options API 代码库 → 参见 [composition-api-options-api-coexistence](reference/composition-api-options-api-coexistence.md)
- 异步操作后生命周期钩子静默失败 → 参见 [composition-api-script-setup-async-context](reference/composition-api-script-setup-async-context.md)
- 来自 React,不必要地过度设计 Vue 模式 → 参见 [composition-api-vs-react-hooks-differences](reference/composition-api-vs-react-hooks-differences.md)
- 父组件 refs 无法访问暴露的属性 → 参见 [define-expose-before-await](reference/define-expose-before-await.md)

### 指令(Directives)
- 跨指令钩子存储状态 → 参见 [directive-arguments-read-only](reference/directive-arguments-read-only.md)
- 将自定义指令应用于 Vue 组件 → 参见 [directive-avoid-on-components](reference/directive-avoid-on-components.md)
- 在指令中创建间隔或事件监听器 → 参见 [directive-cleanup-in-unmounted](reference/directive-cleanup-in-unmounted.md)
- 简化具有相同行为的指令 → 参见 [directive-function-shorthand](reference/directive-function-shorthand.md)
- 在 script setup 中使用自定义指令 → 参见 [directive-naming-v-prefix](reference/directive-naming-v-prefix.md)
- 在自定义指令和内置指令之间选择 → 参见 [directive-prefer-declarative-templating](reference/directive-prefer-declarative-templating.md)
- 在指令和组件之间做出决定 → 参见 [directive-vs-component-decision](reference/directive-vs-component-decision.md)
- 将 Vue 2 指令迁移到 Vue 3 → 参见 [directive-vue2-migration-hooks](reference/directive-vue2-migration-hooks.md)

### 过渡(Transitions)
- 在过渡中包装多个元素或组件 → 参见 [transition-single-element-slot](reference/transition-single-element-slot.md)
- 在相同元素类型之间过渡时没有动画 → 参见 [transition-key-for-same-element](reference/transition-key-for-same-element.md)
- 使用 JavaScript 动画时未调用 done 回调 → 参见 [transition-js-hooks-done-callback](reference/transition-js-hooks-done-callback.md)
- 使用 TransitionGroup 动画列表时没有唯一键 → 参见 [transition-group-key-requirement](reference/transition-group-key-requirement.md)

### 动画(Animation)
- 需要对停留在 DOM 中的元素进行动画处理 → 参见 [animation-class-based-technique](reference/animation-class-based-technique.md)
- 内容更改时动画未触发 → 参见 [animation-key-for-rerender](reference/animation-key-for-rerender.md)
- 使用用户输入构建交互式动画 → 参见 [animation-state-driven-technique](reference/animation-state-driven-technique.md)
- 列表更改动画导致明显延迟 → 参见 [animation-transitiongroup-performance](reference/animation-transitiongroup-performance.md)

### KeepAlive
- 使用 KeepAlive 时没有适当的缓存限制或清理 → 参见 [keepalive-memory-management](reference/keepalive-memory-management.md)
- KeepAlive 的 include/exclude props 与缓存的组件不匹配 → 参见 [keepalive-component-name-requirement](reference/keepalive-component-name-requirement.md)
- 需要以编程方式从 KeepAlive 缓存中删除组件 → 参见 [keepalive-no-cache-removal-vue3](reference/keepalive-no-cache-removal-vue3.md)
- 用户在期望新页面数据时看到陈旧的缓存内容 → 参见 [keepalive-router-fresh-vs-cached](reference/keepalive-router-fresh-vs-cached.md)
- 嵌套 Vue Router 路由时子组件挂载两次 → 参见 [keepalive-router-nested-double-mount](reference/keepalive-router-nested-double-mount.md)
- 将 KeepAlive 与 Transition 动画结合使用时内存增长 → 参见 [keepalive-transition-memory-leak](reference/keepalive-transition-memory-leak.md)
- 在动态组件之间切换时状态重置 → 参见 [dynamic-components-with-keepalive](reference/dynamic-components-with-keepalive.md)

### 异步组件(Async Components)
- 设置 Vue Router 路由组件加载 → 参见 [async-component-vue-router](reference/async-component-vue-router.md)
- 父 Suspense 忽略异步组件选项 → 参见 [async-component-suspense-control](reference/async-component-suspense-control.md)
- 加载组件时出现网络故障或超时 → 参见 [async-component-error-handling](reference/async-component-error-handling.md)
- 使用 SSR 应用程序改进交互时间 → 参见 [async-component-hydration-strategies](reference/async-component-hydration-strategies.md)
- 组件重新激活后模板 refs 未定义 → 参见 [async-component-keepalive-ref-issue](reference/async-component-keepalive-ref-issue.md)
- 快速网络上加载旋转器闪烁 → 参见 [async-component-loading-delay](reference/async-component-loading-delay.md)

### 渲染函数(Render Functions)
- setup 中的渲染函数未响应式更新 → 参见 [rendering-render-function-return-from-setup](reference/rendering-render-function-return-from-setup.md)
- 树中多次出现相同的 vnode → 参见 [render-function-vnodes-must-be-unique](reference/render-function-vnodes-must-be-unique.md)
- 在渲染函数中渲染列表时没有 keys → 参见 [render-function-v-for-keys-required](reference/render-function-v-for-keys-required.md)
- 在渲染函数中实现 .stop、.prevent → 参见 [render-function-event-modifiers](reference/render-function-event-modifiers.md)
- 在渲染函数中的组件上进行双向绑定 → 参见 [render-function-v-model-implementation](reference/render-function-v-model-implementation.md)
- 在渲染函数中使用字符串名称引用组件 → 参见 [rendering-resolve-component-for-string-names](reference/rendering-resolve-component-for-string-names.md)
- 访问 vnode 内部属性如 el 或 shapeFlag → 参见 [render-function-avoid-internal-vnode-properties](reference/render-function-avoid-internal-vnode-properties.md)
- 创建简单的无状态展示组件 → 参见 [render-function-functional-components](reference/render-function-functional-components.md)
- 在渲染函数中应用自定义指令 → 参见 [render-function-custom-directives](reference/render-function-custom-directives.md)
- watchers 或深度 watchers 导致过度重新渲染 → 参见 [rendering-excessive-rerenders-watch-vs-computed](reference/rendering-excessive-rerenders-watch-vs-computed.md)
- 选择渲染函数而不是模板 → 参见 [rendering-prefer-templates-over-render-functions](reference/rendering-prefer-templates-over-render-functions.md)
- 将 Vue 2 渲染函数迁移到 Vue 3 → 参见 [rendering-render-function-h-import-vue3](reference/rendering-render-function-h-import-vue3.md)
- 错误地将插槽内容传递给 h() → 参见 [rendering-render-function-slots-as-functions](reference/rendering-render-function-slots-as-functions.md)
- 了解 Vue 的 vdom 优化块 → 参见 [rendering-understand-vdom-block-structure](reference/rendering-understand-vdom-block-structure.md)

### Teleport
- DOM 中未找到 Teleport 目标元素 → 参见 [teleport-target-must-exist](reference/teleport-target-must-exist.md)
- Teleport 内容破坏 SSR 水合 → 参见 [teleport-ssr-hydration](reference/teleport-ssr-hydration.md)
- 父 CSS 转换破坏模态框 → 参见 [teleport-css-positioning-issues](reference/teleport-css-positioning-issues.md)
- 内容在移动设备上需要不同的布局 → 参见 [teleport-disabled-for-responsive](reference/teleport-disabled-for-responsive.md)
- 不确定 props/events 是否通过 teleport 工作 → 参见 [teleport-logical-hierarchy-preserved](reference/teleport-logical-hierarchy-preserved.md)
- 多个模态框指向同一容器 → 参见 [teleport-multiple-to-same-target](reference/teleport-multiple-to-same-target.md)
- 作用域样式不应用于 teleport 内容 → 参见 [teleport-scoped-styles-limitation](reference/teleport-scoped-styles-limitation.md)

### Suspense
- 需要处理 Suspense 组件的异步错误 → 参见 [suspense-no-builtin-error-handling](reference/suspense-no-builtin-error-handling.md)
- 想要以编程方式跟踪 Suspense 加载状态 → 参见 [suspense-events-for-state-tracking](reference/suspense-events-for-state-tracking.md)
- 在生产应用程序中计划 Suspense 使用 → 参见 [suspense-experimental-api-stability](reference/suspense-experimental-api-stability.md)
- 内容更改时回退未显示 → 参见 [suspense-fallback-not-immediate-on-revert](reference/suspense-fallback-not-immediate-on-revert.md)
- 嵌套 Suspense 组件 → 参见 [suspense-nested-suspensible-prop](reference/suspense-nested-suspensible-prop.md)
- 将 Suspense 与 Router、Transition、KeepAlive 结合使用 → 参见 [suspense-nesting-order-with-router](reference/suspense-nesting-order-with-router.md)
- 嵌套的异步组件未显示加载指示器 → 参见 [suspense-revert-only-on-root-change](reference/suspense-revert-only-on-root-change.md)
- 单个 Suspense 中的多个异步组件 → 参见 [suspense-single-child-requirement](reference/suspense-single-child-requirement.md)
- 在服务器端渲染中使用 Suspense → 参见 [suspense-ssr-hydration-issues](reference/suspense-ssr-hydration-issues.md)

### TypeScript
- 在 composition API 组件中使用 TypeScript 声明 props → 参见 [ts-defineprops-type-based-declaration](reference/ts-defineprops-type-based-declaration.md)
- 为可变 prop 类型提供默认值 → 参见 [ts-withdefaults-mutable-factory-function](reference/ts-withdefaults-mutable-factory-function.md)
- 使用 ref 展开关注点对响应式状态进行类型定义 → 参见 [ts-reactive-no-generic-argument](reference/ts-reactive-no-generic-argument.md)
- 组件挂载后访问 DOM 元素 → 参见 [ts-template-ref-null-handling](reference/ts-template-ref-null-handling.md)
- 对子 Vue 组件的 refs 进行类型定义 → 参见 [ts-component-ref-typeof-instancetype](reference/ts-component-ref-typeof-instancetype.md)
- 使用具有 TypeScript 支持的自定义指令 → 参见 [ts-custom-directive-type-augmentation](reference/ts-custom-directive-type-augmentation.md)
- 使用完全类型安全声明组件事件 → 参见 [ts-defineemits-type-based-syntax](reference/ts-defineemits-type-based-syntax.md)
- 在 TypeScript 中处理可选 boolean props → 参见 [ts-defineprops-boolean-default-false](reference/ts-defineprops-boolean-default-false.md)
- 在 defineProps 中安全使用导入的类型 → 参见 [ts-defineprops-imported-types-limitations](reference/ts-defineprops-imported-types-limitations.md)
- 使用严格的 TypeScript 检查处理 DOM 事件 → 参见 [ts-event-handler-explicit-typing](reference/ts-event-handler-explicit-typing.md)
- 在组件之间以类型安全的方式共享数据 → 参见 [ts-provide-inject-injection-key](reference/ts-provide-inject-injection-key.md)
- 在响应式状态中存储 Vue 组件 → 参见 [ts-shallowref-for-dynamic-components](reference/ts-shallowref-for-dynamic-components.md)
- 在 Vue 模板中使用联合类型 → 参见 [ts-template-type-casting](reference/ts-template-type-casting.md)

### SSR
- 用户数据在服务器请求之间泄漏 → 参见 [state-ssr-cross-request-pollution](reference/state-ssr-cross-request-pollution.md)
- 服务器和客户端渲染之间的 HTML 不同 → 参见 [ssr-hydration-mismatch-causes](reference/ssr-hydration-mismatch-causes.md)
- 代码在服务器和浏览器环境中运行 → 参见 [ssr-platform-specific-apis](reference/ssr-platform-specific-apis.md)
- 自定义指令未在服务器渲染的 HTML 中显示 → 参见 [ssr-custom-directive-getssrprops](reference/ssr-custom-directive-getssrprops.md)

### 性能(Performance)
- 状态更改期间许多列表项不必要地重新渲染 → 参见 [perf-props-stability-update-optimization](reference/perf-props-stability-update-optimization.md)
- 渲染数百或数千个项目导致 DOM 性能问题 → 参见 [perf-virtualize-large-lists](reference/perf-virtualize-large-lists.md)
- 每次父组件更新时静态内容重新评估 → 参见 [perf-v-once-v-memo-directives](reference/perf-v-once-v-memo-directives.md)
- 深度嵌套组件结构导致列表性能下降 → 参见 [perf-avoid-component-abstraction-in-lists](reference/perf-avoid-component-abstraction-in-lists.md)
- Computed 属性返回对象意外触发效果 → 参见 [perf-computed-object-stability](reference/perf-computed-object-stability.md)
- 客户端 JavaScript 执行延迟导致页面加载指标受损 → 参见 [perf-ssr-ssg-for-page-load](reference/perf-ssr-ssg-for-page-load.md)

### SFC (单文件组件)
- 尝试从组件脚本块使用命名导出 → 参见 [sfc-named-exports-forbidden](reference/sfc-named-exports-forbidden.md)
- 使用构建设置启动 Vue 项目 → 参见 [sfc-recommended-for-build-projects](reference/sfc-recommended-for-build-projects.md)
- 使用作用域 CSS 对子组件元素进行样式设置 → 参见 [sfc-scoped-css-child-component-styling](reference/sfc-scoped-css-child-component-styling.md)
- 对使用 v-html 动态添加的内容进行样式设置 → 参见 [sfc-scoped-css-dynamic-content](reference/sfc-scoped-css-dynamic-content.md)
- 优化作用域 CSS 选择器性能 → 参见 [sfc-scoped-css-performance](reference/sfc-scoped-css-performance.md)
- 对通过组件插槽传递的内容进行样式设置 → 参见 [sfc-scoped-css-slot-content](reference/sfc-scoped-css-slot-content.md)
- 更改后模板中的变量未更新 → 参见 [sfc-script-setup-reactivity](reference/sfc-script-setup-reactivity.md)
- 组织组件模板、逻辑和样式 → 参见 [sfc-separation-of-concerns-colocate](reference/sfc-separation-of-concerns-colocate.md)
- 使用属性名称绑定内联样式 → 参见 [style-binding-camelcase](reference/style-binding-camelcase.md)
- 使用字符串连接构建 Tailwind 类 → 参见 [tailwind-dynamic-class-generation](reference/tailwind-dynamic-class-generation.md)

### 插件(Plugins)
- 调试全局属性导致命名冲突的原因 → 参见 [plugin-global-properties-sparingly](reference/plugin-global-properties-sparingly.md)
- 插件不工作或 inject 返回 undefined → 参见 [plugin-install-before-mount](reference/plugin-install-before-mount.md)
- 全局属性在 setup 函数中不可用 → 参见 [plugin-prefer-provide-inject-over-global-properties](reference/plugin-prefer-provide-inject-over-global-properties.md)
- 从头创建新的 Vue 插件 → 参见 [plugin-structure-install-method](reference/plugin-structure-install-method.md)
- 防止多个插件之间的冲突 → 参见 [plugin-symbol-injection-keys](reference/plugin-symbol-injection-keys.md)
- 全局属性缺少 TypeScript 自动完成支持 → 参见 [plugin-typescript-type-augmentation](reference/plugin-typescript-type-augmentation.md)

### 应用配置(App Configuration)
- 挂载调用后应用配置方法不工作 → 参见 [configure-app-before-mount](reference/configure-app-before-mount.md)
- 需要在挂载后链式调用应用配置方法 → 参见 [mount-return-value](reference/mount-return-value.md)
- Vue 仅控制特定页面部分 → 参见 [multiple-app-instances](reference/multiple-app-instances.md)
- 将动态组件注册迁移到 Vite → 参见 [dynamic-component-registration-vite](reference/dynamic-component-registration-vite.md)
